generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  createdAt    DateTime @default(now())
  tier         String   @default("free")

  providerAccounts ProviderAccount[]
  subscription     Subscription?
  usageCounters    UsageCounter[]
}

model Account {
  id            String   @id @default(cuid())
  countryCode   String?  @default("DE")
  iban          String?
  bic           String?
  name          String?
  institution   String?
  createdAt     DateTime @default(now())
  // Relations
  imports       Import[]
  transactions  Transaction[]
}

model Import {
  id         String   @id @default(cuid())
  accountId  String
  bankAdapter String?
  fileHash   String?  @unique
  importedAt DateTime @default(now())
  // Relations
  account    Account  @relation(fields: [accountId], references: [id])
  transactions Transaction[]
}

model Transaction {
  id              String   @id @default(cuid())
  accountId       String
  importId        String
  bookingDate     String
  valueDate       String?
  amount          Decimal
  currency        String?  @default("EUR")
  balanceAfter    Decimal?
  txType          String?
  counterpartName String?
  counterpartIban String?
  counterpartBic  String?
  mandateRef      String?
  creditorId      String?
  endToEndId      String?
  purpose         String?
  rawCode         String?
  mcc             String?
  merchantId      String?
  categoryId      String?
  categoryConfidence Float?
  isRecurring     Boolean  @default(false)
  recurrenceKey   String?
  userNote        String?
  createdAt       DateTime @default(now())
  // Relations
  account         Account  @relation(fields: [accountId], references: [id])
  import          Import   @relation(fields: [importId], references: [id])
  category        Category? @relation(fields: [categoryId], references: [id])
  aiInferences    AIInference[]
}


// Pro tier models
model ProviderAccount {
  id                String   @id @default(cuid())
  userId            String
  provider          String
  providerAccountId String
  institutionName   String?
  mask              String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokens  ProviderToken[]
  cursors SyncCursor[]
  jobs    SyncJob[]

  @@unique([userId, provider, providerAccountId])
  @@map("provider_accounts")
}

model ProviderToken {
  id                 String   @id @default(cuid())
  providerAccountId  String
  accessTokenEnc     String
  refreshTokenEnc    String?
  expiresAt          DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  account ProviderAccount @relation(fields: [providerAccountId], references: [id], onDelete: Cascade)
  @@map("provider_tokens")
}

model SyncJob {
  id                String   @id @default(cuid())
  providerAccountId String
  status            String
  startedAt         DateTime?
  finishedAt        DateTime?
  error             String?
  createdAt         DateTime @default(now())

  account ProviderAccount @relation(fields: [providerAccountId], references: [id], onDelete: Cascade)
  @@map("sync_jobs")
}

model SyncCursor {
  id                String   @id @default(cuid())
  providerAccountId String
  accountId         String
  sinceCursor       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  account ProviderAccount @relation(fields: [providerAccountId], references: [id], onDelete: Cascade)
  @@unique([providerAccountId, accountId])
  @@map("sync_cursors")
}

model Subscription {
  id        String   @id @default(cuid())
  userId    String   @unique
  plan      String
  status    String
  renewsAt  DateTime?
  stripeSubscriptionId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@map("subscriptions")
}

model UsageCounter {
  id          String   @id @default(cuid())
  userId      String
  period      String
  aiCalls     Int      @default(0)
  connections Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([userId, period])
  @@map("usage_counters")
}

model AIInference {
  id                   String   @id @default(cuid())
  transactionId        String
  model                String
  suggestionCategoryId String?
  confidence           Float?
  reasonJson           String?
  createdAt            DateTime @default(now())

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  @@map("ai_inferences")
}

model Category {
  id           String        @id @default(cuid())
  name         String        @unique
  parentId     String?
  createdAt    DateTime      @default(now())
  // Relations
  transactions Transaction[]

  @@map("categories")
}

